## База данных

У любой SQL базы данных есть несколько основных типов полей:

1. **integer - цифровое поле от 2147483647 до -2147483647**
2. **varchar - текстовое поле с максимальной длиной 255 байт**
3. **bool - сахар для tinyint с длиной 1**
4. **text - текстовое поле без ограчниений по длине но до 65кб**
5. **tinyint - цифровое поле от -128 до 128**
6. **decimal - число с плавающей точко с определенной длиной после запятой**
7. date - даты
8. datetime - дата с временем
9. timestamp - время в UNIX - формате
10. json - json
11. float - число с плавающей точкой
12. MEDIUMTEXT - текстовое поле до 4мб
13. char - текстовое поле, с фиксированной длиной в 10 байт
14. tinytext - текстовое поле с максимальной длиной 255 байт

Также у баз данных есть разные индексы, например
primary key - первичный индекс - индекс определяющий уникальность записи (чаще всего id)
unsigned - индекс говорящий о том, что числовое поле имеет только положительные числа
unique - индекс, говорящий о том, что значение в этом поле, должно быть уникальным по отношению к другим записям

[Индексы для чайников](http://yapro.ru/article/6280)

### Синтаксис

#### Создание таблицы
Типичное создание таблицы выглядит так:
```sql
create table if not exists table_name
(
    id          bigint unsigned unique primary key auto_increment,
    name        varchar(255) not null,
    description text         null,
    active      tinyint(1) default 0
);

CREATE INDEX table_name__index_active
    on table_name (active);
```

Операция create table (if not exists которая говорит что 
создавать только если не существует такой таблицы) , название 
таблицы и перечисление полей, где:
1. id - это большое число 2 в 63 степени, которое уникальное и является 
первичным ключем, с автоинкриментом
2. name - varchar на 255 байт которое не пустое
3. description - с типом данных text которое по умолчанию null
4. active - tinyint на 1 байт с значением по умолчанию 0

А также вторая операция на создание индекса для поля active, название 
индекса может быть любым, но как правило индексы называются в таком формате:
названиетаблицы__index_названиеполя

#### Вставка данных

```sql
INSERT INTO
    table_name (name, description)
    VALUES ('Тестовое название', 'Тестовое описание')
```

Вставить в table_name (поля в которые будем вставлять) 
VALUES (значения в которые будем вставлять)

#### Изменение таблицы
Изменение таблицы происходит через оператор ALTER TABLE, мы
указываем название таблицы, а дальше операцию которую нам
необходимо сделать, например:
```sql
ALTER TABLE table_name ADD age INT UNSIGNED NOT NULL;
```

```sql
ALTER TABLE table_name MODIFY description varchar(255) NULL;
```

```sql
ALTER TABLE table_name CHANGE description description varchar(255) COMMENT 'Описание';
```

```sql
ALTER TABLE table_name CHANGE description description text;
```

_P.s. поля можно менять через MODIFY либо через CHANGE_
_P.p.s. когда мы меняем поля, мы меняем его полностью, т.е. вся 
предыдущая  мета-информация или информация о длине поля, или 
пр. стирается_


#### Выборка данных (начальная)
Чтобы получить данные необходимо сделать операцию SELECT

```sql
SELECT id, name FROM table_name
ORDER BY id desc
LIMIT 10
OFFSET 10
```
Указываем какие поля выбираем, если все, то "*", указываем из какой 
таблицы выбираем, указываем сортировку по id в обратном направлении
(desc/asc), указываем то что выбираем 10 записей и пропускаем от начала
10 записей (OFFSET)

#### WHERE
WHERE указывает на то какие именно записи мы выбираем, например
```sql
SELECT id, name FROM table_name
WHERE active = 1
```
Выбираем все записи с active 1
Также поддержирваются и любые другие логические операторы

Один из самых неочевидных операторов - оператор поиска (LIKE), 
синтаксис его записи следующий

```sql
SELECT id, name FROM table_name
WHERE name LIKE '%Павел%'
```

Т.е. мы говорим что name может начинаться с чего угодно (%) 
содержать Павел и заканчиваться чем угодно (%). На операторе LIKE 
реализуются самые простые поиски (например поиск ресурсов в modx),
но нужно всегда учитывать что оператор LIKE безумно медленный оператор.

Также WHERE поддерживает такие логические операторы как AND и OR:
```sql
SELECT id, name, age FROM table_name
WHERE name LIKE '%Павел%' 
    AND age > 25
```

### Изменение данных
В MYSQL данные изменяются по умолчанию для всех полей входящих в 
выборку
```sql
UPDATE table_name
    SET name = 'Этому объекту больше 5 лет'
WHERE age > 5
```

```sql
UPDATE table_name 
    SET name = 'Изменим имя всем объектам'
```

### Связи и соединения
В MYSQL есть такая сущность как внешние ключи, внешние ключи описывают
связь между двумя таблицами, а также что делать с этой связью.

#### Связь через промежуточную таблицу
Рассмотрим на примере:
У нас электронный дневник, у дневника есть 2 сущности:
- Пользователь (id, name, type)
- Оценки пользователя (id, score)

Сущности эти между собой никак не связаны, т.к. у пользователя может 
не быть оценок (например это родитель)

Создаем таблицы пользователя и оценок

```sql
create table if not exists users
(
    id          bigint unsigned unique primary key auto_increment,
    name        varchar(255) not null,
    type        integer not null
);

create table if not exists rating
(
    id          bigint unsigned unique primary key auto_increment,
    score       tinyint null
);
```

Создаем промежуточную таблицу по которой будем
связывать две таблицы
```sql
create table users_rating
(
    rating_id bigint unsigned,
    user_id bigint unsigned
);
```

Теперь, у нас есть три таблицы, но MYSQL не
знает как они связаны между собой, по этому
нам необходимо добавить FORIGIN KEY связь,
а также указать что нужно делать при удалении
оценки или пользователя

```sql
ALTER TABLE users_rating
    ADD FOREIGN KEY (rating_id)
    REFERENCES rating (id)
    ON DELETE CASCADE;

ALTER TABLE users_rating
    ADD FOREIGN KEY (user_id)
    REFERENCES users (id)
    ON DELETE CASCADE;
```

##### Выборка через промежуточную таблицу
Для выборки через промежуточную таблицу нам
надо использовать присоеденения

```sql
SELECT u.id, u.name, r.score
from users as u
         left join users_rating as ur
                   on u.id = ur.user_id
         inner join rating as r
                   on ur.rating_id = r.id
```

В данном случае мы говорим к выборке 
присоеденить users_rating
по users.id = user_rating.user_id
а также присоеденить таблицу rating 
по user_rating.rating_id = rating.id
При том т.к. это inner join значения должны быть валидными
и в user_rating и в rating, т.е. у пользователя 100% должна быть 
связь между rating в таблице users_rating, а также rating должен 
существовать

_Если бы в users_rating стоял бы right_join, то в выборку попали бы 
ТОЛЬКО пользователи у которых есть связь с users_rating, но не 
обязательно есть оценки_

_Если бы в users_rating стоял бы left_join, то в выборку попали бы даже 
те пользователи, у которых нет связи с users_rating, но это невозможно т.к.
у нас стоит inner join у таблицы rating, которая связыватся через users_rating_

_Если бы в rating стоял бы left join, то в выборку попали бы те пользователи, у 
которых есть связь, но нет оценок_

_Если бы в rating стоял бы right join, то в выборку попали бы только те, 
у которых 100% оценка есть, даже если нет связи (что невозможно)_

По этому мы используем везде inner join потому что нам нужны только 
пользователи которые имеют И СВЯЗЬ И ОЦЕНКУ

#### Связь напрямую
В отличии от связи через промежуточную таблицу, связь напрямую значительно легче, и ее нужно использовать
только тогда, когда записи в таблице принадлежат только одной сущности, или нескольким одновременно, например:

У пользователей есть какая то дополнительная информация, допустим это адрес, номер телефона, фото, пол
Для этого мы создаем отдельную таблицу, но эти данные не могут существовать без пользователя отдельно

Создадим таблицу с данными пользователя:
```sql
create table if not exists user_data
(
    id      bigint unsigned unique primary key auto_increment,
    address varchar(255) null,
    phone   varchar(255) null,
    photo   varchar(255) null,
    gender  tinyint(1) default 0,
    user_id bigint unsigned,
    FOREIGN KEY (user_id)
    REFERENCES users (id)
    ON DELETE CASCADE
);
```
Т.е. мы создаем таблицу с необходмыми нам полями, и с прямой связью 
через поле user_id

Соответственно выборка будет выглядеть так:

```sql
SELECT u.id, u.name, ud.phone
from users as u
    left join user_data as ud
        on ud.user_id = u.id
```

Тоесть связь через промежуточную таблицу мы используем
только тогда, когда объекты в обоих таблицах могут существовать
отдельно друг от друга (например таблица с блюдами и таблица с 
ингридиентами)

Связь напрямую мы используем, когда зависимая таблица не может
существовать без главной таблицы (например таблица с блюдами и таблица с их параметрами: каллории, вес...)

# Задание:
В laravel создать следующие модели и к ним миграции со связями:

1. Модель пользователей (уже есть)
2. Модель данных пользователя (телефон, улица, дом, город, регион)
3. Модель департамента (отдела) (айди, название, адрес офиса)
4. Модель клиента (имя, емейл)
5. Модель данных клиента (тоже что и с данными пользователя)
6. Модель задач (заголовок, описание, датавремя создания)
7. Модель комментариев (текст, датавремя создания)
8. Модель оплат (транзаций) (сумма (decimal 12.2), тип опалты (входящая/исходящая, числом))

- Пользователь привязан к отделу
- Задачи могут быть привязаны к пользователю
- Задачи могут быть привязаны к клиенту
- Оплаты могут быть привязаны к клиенту
- Оплаты могут быть привязаны к задаче
- Комментарии привязаны только к задаче и каждый комментарий привязан к
пользователю
- Данные клинета могут быть привязаны к клиенту
- Данные пользователя могут быть привязаны к пользователелю

Генерируем миграции таким образом
`php artisan make:model ModelName -m`
Не забываем что модель - в единичном числе, миграции 
сгенерируются во множественном
